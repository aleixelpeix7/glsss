<!doctype html>
<html lang="ca">
<head>
  <meta charset="utf-8" />
  <title>Laberint | LAG</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" href="assets/favicon.png" type="image/png" />
  <style>
    :root{
      --bg:#002244;
      --accent:#7CCF35;
      --nav-bg: rgba(0,0,0,0.7);
      --muted: rgba(255,255,255,0.08);
      --wall:#0b3d91;
      --floor:#001a33;
      --player:#ffbf69;
      --goal:#7CCF35;
      --card: linear-gradient(180deg,#001829 0%, #00283a 100%);
    }
    html,body{height:100%;margin:0;padding:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:var(--accent)}
    *,*::before,*::after{box-sizing:border-box}

    nav{background:var(--nav-bg);padding:1rem 1.25rem;position:sticky;top:0;z-index:100}
    nav ul{list-style:none;display:flex;align-items:center;justify-content:space-between;margin:0;padding:0}
    nav li.logo{display:flex;align-items:center}
    nav li.logo img{height:56px;margin-right:0.5rem}
    nav a{color:white;text-decoration:none;font-weight:700}
    nav a:hover{color:#ffff66}

    main{padding:2rem;min-height:calc(100vh - 120px);display:grid;grid-template-columns:1fr 320px;gap:20px;align-items:start}
    @media (max-width:900px){ main{grid-template-columns:1fr} }

    .panel{background:var(--card);border-radius:12px;padding:14px;border:1px solid var(--muted);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
    h1{margin:0 0 10px 0;color:var(--accent);font-size:20px}

    /* canvas area */
    .game-wrap{display:flex;flex-direction:column;gap:12px;align-items:center}
    canvas{background:var(--floor);border-radius:10px;width:100%;height:auto;box-shadow:0 8px 24px rgba(0,0,0,0.6);max-width:780px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--accent);color:#05211a;border:0;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent)}
    .muted{color:rgba(255,255,255,0.65);font-size:13px}

    .stats{display:flex;gap:8px;margin-top:8px}
    .stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-weight:700;color:#cfeea6;min-width:90px;text-align:center}

    /* mobile pad */
    .mobile-pad{display:none;margin-top:8px;gap:6px}
    .pad-row{display:flex;gap:6px;justify-content:center}
    .pad-btn{width:56px;height:56px;border-radius:10px;background:#02131a;border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:800;cursor:pointer}
    @media (max-width:900px){ .mobile-pad{display:block} }

    /* First-visit modal (estil com el teu exemple) */
    .fv-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.62);display:flex;align-items:center;justify-content:center;z-index:9999;padding:1rem}
    .fv-modal{background:var(--card);border-radius:10px;width:780px;max-width:98%;height:80vh;max-height:95vh;box-shadow:0 12px 30px rgba(0,0,0,0.6);display:flex;flex-direction:column;overflow:hidden;border:1px solid rgba(124,207,53,0.08)}
    .fv-header{display:flex;align-items:center;justify-content:space-between;padding:0.6rem 0.9rem;color:#cfeea6;font-weight:700;gap:0.75rem;flex:0 0 auto}
    .fv-title{font-size:16px}
    .fv-close{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff;padding:0.35rem 0.6rem;border-radius:6px;cursor:pointer;font-size:14px}
    .fv-body{padding:12px;flex:1 1 auto;overflow:auto;color:#d6f7b6}
    @media (max-width:720px){ .fv-modal{width:100%;height:95vh;border-radius:8px} }

    footer{grid-column:1/-1;text-align:center;color:rgba(255,255,255,0.45);margin-top:12px;font-size:13px}
  </style>
</head>
<body>

  <nav>
    <ul>
      <li class="logo"><a href="index.html"><img src="assets/logo.png" alt="Logo LAG"></a></li>
      <li><a href="https://lagg.netlify.app/contacte">Contactar</a></li>
    </ul>
  </nav>

  <main>
    <section class="panel">
      <h1>Joc de laberint</h1>
      <div class="game-wrap">
        <canvas id="mazeCanvas" width="700" height="700" aria-label="Laberint"></canvas>

        <div class="controls" style="width:100%;justify-content:space-between">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="restartBtn">Reinicia</button>
            <button class="secondary" id="solveBtn">Mostra camí</button>
            <div class="muted" style="margin-left:8px">Mida:
              <select id="sizeSelect" style="margin-left:6px;background:transparent;color:var(--accent);border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:6px">
                <option value="11">11×11</option>
                <option value="17">17×17</option>
                <option value="23" selected>23×23</option>
                <option value="31">31×31</option>
                <option value="41">41×41</option>
              </select>
            </div>
          </div>

          <div style="display:flex;align-items:center;gap:10px">
            <div class="stats"><div class="stat">Temps<br><span id="time">0.0s</span></div></div>
            <div class="stats"><div class="stat">Passos<br><span id="steps">0</span></div></div>
          </div>
        </div>

        <div class="mobile-pad" aria-hidden="false">
          <div class="pad-row"><button class="pad-btn" data-dir="up">▲</button></div>
          <div class="pad-row"><button class="pad-btn" data-dir="left">◀</button><div style="width:8px"></div><button class="pad-btn" data-dir="right">▶</button></div>
          <div class="pad-row"><button class="pad-btn" data-dir="down">▼</button></div>
        </div>

        <p class="muted" style="width:100%;text-align:center;margin-top:6px">Controls: fletxes o WASD. En dispositius mòbils utilitza el pad.</p>
      </div>
    </section>

    <aside class="panel" aria-labelledby="aboutTitle">
      <h1 id="aboutTitle">Sobre</h1>
      <p class="muted">Aquest laberint es genera proceduralment amb l'algorisme DFS. L'objectiu és arribar a la meta verda.</p>
      <h1 style="margin-top:12px">Enllaços</h1>
      <p><a class="muted" href="https://lagg.netlify.app/serpiente" target="_blank" rel="noreferrer">Serpiente</a></p>
      <p><a class="muted" href="https://lagg.netlify.app/memovisual" target="_blank" rel="noreferrer">Memo-visual</a></p>
    </aside>

    <footer>Prova de laberint — disseny estil LAG</footer>
  </main>

  <!-- First-visit modal -->
  <div id="fv" class="fv-backdrop" role="dialog" aria-modal="true" style="display:none">
    <div class="fv-modal">
      <div class="fv-header">
        <div class="fv-title">Benvingut al Laberint</div>
        <button class="fv-close" id="fvClose">Començar</button>
      </div>
      <div class="fv-body">
        <p style="margin-top:0">Benvingut! Mou el punt groc amb les fletxes o WASD. Pots canviar la mida del laberint a la dreta i prémer "Mostra camí" per veure la solució des de la teva posició actual. En mànic, utilitza el pad direccional.</p>
        <p class="muted">Consell: els laberints amb mida imparell garanteixen una sola solució perfecta generada amb DFS.</p>
      </div>
    </div>
  </div>

<script>
/* Joc: generador DFS, render canvas, moviment, solve BFS, modal primer cop */
(() => {
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  const restartBtn = document.getElementById('restartBtn');
  const solveBtn = document.getElementById('solveBtn');
  const sizeSelect = document.getElementById('sizeSelect');
  const timeEl = document.getElementById('time');
  const stepsEl = document.getElementById('steps');
  const padBtns = document.querySelectorAll('.pad-btn');
  const fv = document.getElementById('fv');
  const fvClose = document.getElementById('fvClose');

  let cols = parseInt(sizeSelect.value,10);
  let rows = cols;
  let maze = [];
  let player = {x:0,y:0};
  let goal = {x:cols-1,y:rows-1};
  let steps = 0;
  let startTime = performance.now();
  let timerId = null;
  let solvingPath = null;
  let cellPx = 28;

  function fitCanvas(){
    // manté canvas quadrat i adapta a l'amplada disponible
    const parentWidth = Math.min(780, Math.max(320, Math.floor(window.innerWidth * 0.55)));
    canvas.width = parentWidth;
    canvas.height = parentWidth;
    cellPx = Math.floor(canvas.width / cols);
    draw();
  }
  window.addEventListener('resize', fitCanvas);

  function updateTimer(){
    const elapsed = (performance.now() - startTime) / 1000;
    timeEl.textContent = elapsed.toFixed(1) + 's';
    timerId = requestAnimationFrame(updateTimer);
  }

  function initMaze(){
    cols = parseInt(sizeSelect.value,10);
    rows = cols;
    maze = [];
    for(let y=0;y<rows;y++){
      const row = [];
      for(let x=0;x<cols;x++){
        row.push({x,y,visited:false,walls:[true,true,true,true]});
      }
      maze.push(row);
    }
    // DFS backtracker
    const stack = [];
    const start = maze[0][0];
    start.visited = true;
    stack.push(start);
    const dirs = [
      {dx:0,dy:-1,wall:0,opp:2},
      {dx:1,dy:0,wall:1,opp:3},
      {dx:0,dy:1,wall:2,opp:0},
      {dx:-1,dy:0,wall:3,opp:1},
    ];
    while(stack.length){
      const cur = stack[stack.length-1];
      const neighbors = [];
      for(const d of dirs){
        const nx = cur.x + d.dx, ny = cur.y + d.dy;
        if(nx>=0 && nx<cols && ny>=0 && ny<rows && !maze[ny][nx].visited){
          neighbors.push({d,nx,ny});
        }
      }
      if(neighbors.length){
        const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
        const nxt = maze[pick.ny][pick.nx];
        cur.walls[pick.d.wall] = false;
        nxt.walls[pick.d.opp] = false;
        nxt.visited = true;
        stack.push(nxt);
      } else stack.pop();
    }
    // ensure openings
    maze[0][0].walls[3] = false;
    maze[rows-1][cols-1].walls[1] = false;

    player = {x:0,y:0};
    goal = {x:cols-1,y:rows-1};
    steps = 0;
    startTime = performance.now();
    solvingPath = null;
    updateStats();
    fitCanvas();
    if(timerId) cancelAnimationFrame(timerId);
    timerId = requestAnimationFrame(updateTimer);
  }

  function updateStats(){
    stepsEl.textContent = steps;
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const cs = Math.floor(canvas.width / cols);
    // background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--floor') || '#001a33';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // walls
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall') || '#0b3d91';
    ctx.lineWidth = Math.max(2, cs/12);
    ctx.lineCap = 'square';

    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const cell = maze[y][x];
        const px = x*cs, py = y*cs;
        ctx.beginPath();
        if(cell.walls[0]){ ctx.moveTo(px,py); ctx.lineTo(px+cs,py); }
        if(cell.walls[1]){ ctx.moveTo(px+cs,py); ctx.lineTo(px+cs,py+cs); }
        if(cell.walls[2]){ ctx.moveTo(px+cs,py+cs); ctx.lineTo(px,py+cs); }
        if(cell.walls[3]){ ctx.moveTo(px,py+cs); ctx.lineTo(px,py); }
        ctx.stroke();
      }
    }

    // solution path
    if(solvingPath){
      ctx.fillStyle = 'rgba(124,207,53,0.14)';
      for(const p of solvingPath){
        ctx.fillRect(p.x*cs+1, p.y*cs+1, cs-2, cs-2);
      }
    }

    // goal
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--goal') || '#7CCF35';
    ctx.beginPath();
    ctx.arc(goal.x*cs + cs/2, goal.y*cs + cs/2, cs*0.30, 0, Math.PI*2);
    ctx.fill();

    // player
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player') || '#ffbf69';
    ctx.beginPath();
    ctx.arc(player.x*cs + cs/2, player.y*cs + cs/2, cs*0.28, 0, Math.PI*2);
    ctx.fill();
  }

  function canMoveFrom(x,y,dir){
    const cell = maze[y][x];
    if(dir==='up') return !cell.walls[0];
    if(dir==='right') return !cell.walls[1];
    if(dir==='down') return !cell.walls[2];
    if(dir==='left') return !cell.walls[3];
    return false;
  }

  function tryMove(dir){
    if(!canMoveFrom(player.x,player.y,dir)) return false;
    let nx = player.x, ny = player.y;
    if(dir==='up') ny--;
    if(dir==='down') ny++;
    if(dir==='left') nx--;
    if(dir==='right') nx++;
    if(nx<0||ny<0||nx>=cols||ny>=rows) return false;
    player.x = nx; player.y = ny;
    steps++;
    updateStats();
    draw();
    checkWin();
    return true;
  }

  function checkWin(){
    if(player.x===goal.x && player.y===goal.y){
      const elapsed = ((performance.now()-startTime)/1000).toFixed(2);
      setTimeout(()=> alert(`Has guanyat! Temps: ${elapsed}s  Passos: ${steps}`), 120);
    }
  }

  function solveMaze(){
    const q = [];
    const visited = Array(rows).fill(0).map(()=>Array(cols).fill(false));
    const parent = Array(rows).fill(0).map(()=>Array(cols).fill(null));
    q.push({x:player.x,y:player.y});
    visited[player.y][player.x] = true;
    while(q.length){
      const cur = q.shift();
      if(cur.x===goal.x && cur.y===goal.y){
        const path = [];
        let p = cur;
        while(p){
          path.push({x:p.x,y:p.y});
          p = parent[p.y][p.x];
        }
        solvingPath = path.reverse();
        draw();
        return;
      }
      const dirs = [
        {dir:'up',dx:0,dy:-1},
        {dir:'right',dx:1,dy:0},
        {dir:'down',dx:0,dy:1},
        {dir:'left',dx:-1,dy:0},
      ];
      for(const d of dirs){
        const nx = cur.x + d.dx, ny = cur.y + d.dy;
        if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
        if(!canMoveFrom(cur.x,cur.y,d.dir)) continue;
        if(!visited[ny][nx]){
          visited[ny][nx] = true;
          parent[ny][nx] = cur;
          q.push({x:nx,y:ny});
        }
      }
    }
  }

  // keyboard controls with simple rate limit
  let lastMove = 0;
  window.addEventListener('keydown',(e)=>{
    const now = performance.now();
    if(now - lastMove < 60) return; // tiny debounce for fluid control
    const k = e.key.toLowerCase();
    let moved = false;
    if(k==='arrowup' || k==='w') moved = tryMove('up');
    if(k==='arrowdown' || k==='s') moved = tryMove('down');
    if(k==='arrowleft' || k==='a') moved = tryMove('left');
    if(k==='arrowright' || k==='d') moved = tryMove('right');
    if(moved) lastMove = now;
  });

  padBtns.forEach(btn=>{
    btn.addEventListener('click', ()=> tryMove(btn.dataset.dir));
  });

  // UI events
  restartBtn.addEventListener('click', ()=> initMaze());
  solveBtn.addEventListener('click', ()=> solveMaze());
  sizeSelect.addEventListener('change', ()=> initMaze());

  // modal first visit: simple localStorage flag
  function showFV(){
    const seen = localStorage.getItem('lag_maze_seen_v1');
    if(!seen){
      fv.style.display = 'flex';
    }
  }
  fvClose.addEventListener('click', ()=>{
    localStorage.setItem('lag_maze_seen_v1','1');
    fv.style.display = 'none';
  });

  // initial boot
  initMaze();
  showFV();
})();
</script>
</body>
</html>
