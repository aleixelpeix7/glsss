<!doctype html>
<html lang="ca">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Joc de laberint | LAG</title>
  <link rel="icon" href="assets/favicon.png" type="image/png" />
  <style>
    :root{
      --bg:#002244;
      --panel:#0b2a44;
      --accent:#FFDF20;
      --accent-2:#FB2C36;
      --muted:#888;
      --wall:#0b3d91;
      --floor:#111827;
      --player:#FFBF69;
      --goal:#7CCF35;
      --btn-bg: #FFDF20;
      --btn-fg: #FB2C36;
      --wrap-w:400px;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      background:var(--bg);
      color:#FAFAF9;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:22px 12px;
      gap:12px;
    }

    nav{
      position:sticky;top:0;width:100%;max-width:920px;background:rgba(0,0,0,0.6);
      padding:14px 18px;border-radius:8px;margin-bottom:10px;
    }
    nav ul{display:flex;justify-content:space-between;align-items:center;list-style:none}
    nav li.logo img{height:52px}
    nav a{color:#fff;text-decoration:none;font-weight:700}
    nav a:hover{color:#ffff66}

    main{width:100%;max-width:920px;display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap;justify-content:center}

    /* compacte game wrap */
    #gameWrap{position:relative;width:var(--wrap-w);min-width:260px}
    canvas{width:100%;height:auto;display:block;background:var(--floor);border:2px solid #222;border-radius:6px}
    h1{font-size:18px;margin-bottom:8px;text-align:center}

    /* botons sobre el canvas */
    .canvas-button{
      position:absolute;
      background:var(--btn-bg);
      color:var(--btn-fg);
      border:1px solid rgba(0,0,0,0.25);
      padding:8px 12px;
      font-size:14px;
      cursor:pointer;
      border-radius:8px;
      box-shadow:0 6px 18px rgba(0,0,0,0.45);
      user-select:none;
      z-index:30;
      transform:translateX(-50%);
      white-space:nowrap;
    }
    #startButton{left:50%;top:50%;transform:translate(-50%,-50%);font-weight:800}
    #pauseContinue{left:50%;top:12px;transform:translateX(-50%);display:none}
    #pauseReset{left:calc(100% - 14px);top:12px;transform:translate(-100%,0);display:none}
    #gameOverReset{left:50%;top:50%;transform:translate(-50%,-50%);display:none}

    .hidden{display:none}
    #score{color:var(--muted);font-size:14px;text-align:center;margin-top:8px}

    /* controls / pad (visible a m√≤bil) */
    .mobile-pad{display:none;margin-top:10px;gap:8px;justify-content:center}
    .pad-row{display:flex;gap:8px;justify-content:center}
    .pad-btn{width:48px;height:48px;border-radius:8px;background:#07131a;border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;color:var(--accent);font-weight:800;cursor:pointer}
    @media (max-width:560px){
      #gameWrap{width:92vw;max-width:420px}
      .pad-row{gap:6px}
      .mobile-pad{display:flex;flex-direction:column}
      #pauseContinue{display:block}
      #pauseReset{display:block}
    }

    /* info panel */
    .panel{background:transparent;color:var(--accent);max-width:420px}
    .muted{color:#d3eab2}
  </style>
</head>
<body>
  <nav style="max-width:920px;">
    <ul>
      <li class="logo"><a href="https://lagg.netlify.app"><img src="assets/logo.png" alt="logo"></a></li>
      <li style="display:flex;gap:18px;align-items:center">
        <a href="https://lagg.netlify.app">Inici</a>
        <a href="https://lagg.netlify.app/contacte">Contactar</a>
      </li>
    </ul>
  </nav>

  <main>
    <section id="gameArea" style="display:flex;flex-direction:column;align-items:center;gap:6px">
      <h1>üî∑ Laberint compacte</h1>
      <div id="gameWrap" aria-live="polite">
        <canvas id="mazeCanvas" width="400" height="400" aria-label="Laberint"></canvas>

        <button id="startButton" class="canvas-button" aria-label="Comen√ßar">‚ñ∂Ô∏è Comen√ßar</button>
        <button id="pauseContinue" class="canvas-button" aria-label="Pausa Continuar">‚èØ</button>
        <button id="pauseReset" class="canvas-button" aria-label="Reiniciar">üîÅ</button>
        <button id="gameOverReset" class="canvas-button" aria-label="Reiniciar final">üîÅ Reiniciar</button>

        <div class="mobile-pad" style="position:relative;top:10px">
          <div class="pad-row"><button class="pad-btn" data-dir="up">‚ñ≤</button></div>
          <div class="pad-row"><button class="pad-btn" data-dir="left">‚óÄ</button><div style="width:8px"></div><button class="pad-btn" data-dir="right">‚ñ∂</button></div>
          <div class="pad-row"><button class="pad-btn" data-dir="down">‚ñº</button></div>
        </div>
      </div>

      <p id="score">Passos: <span id="steps">0</span> ¬∑ Temps: <span id="time">0.0s</span></p>
    </section>

    <aside class="panel" style="max-width:420px">
      <div style="background:transparent;padding:12px;border-radius:10px">
        <h2 style="margin-bottom:6px;color:var(--accent)">Controls</h2>
        <p class="muted" style="margin-bottom:6px">Fletxes o WASD; en m√≤bil usa el pad groc. Prem "Mostra cam√≠" per veure la soluci√≥.</p>

        <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
          <label style="color:var(--muted);font-weight:700">Mida</label>
          <select id="sizeSelect" style="margin-left:8px;background:#07131a;color:var(--accent);border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px">
            <option value="11">11√ó11</option>
            <option value="17">17√ó17</option>
            <option value="23" selected>23√ó23</option>
            <option value="31">31√ó31</option>
          </select>
        </div>

        <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap">
          <button id="restartBtn" style="background:var(--btn-bg);color:var(--btn-fg);padding:8px 12px;border-radius:8px;border:0;font-weight:800">Reinicia</button>
          <button id="solveBtn" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent);padding:8px 12px;border-radius:8px;font-weight:700">Mostra cam√≠</button>
        </div>

        <p style="margin-top:14px;color:#cfeea6;font-weight:700">Sobre</p>
        <p class="muted" style="font-size:13px">Laberint generat per DFS. S'ha adaptat l'interf√≠cie perqu√® sembli el teu joc de la serp: botons grans sobre el canvas, tamany compacte i pad m√≤bil.</p>
      </div>
    </aside>
  </main>

<script>
/* Laberint compacte: DFS generator, render, moviment, solve BFS, botons similars a snake */
(() => {
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  const startButton = document.getElementById('startButton');
  const pauseContinue = document.getElementById('pauseContinue');
  const pauseReset = document.getElementById('pauseReset');
  const gameOverReset = document.getElementById('gameOverReset');
  const restartBtn = document.getElementById('restartBtn');
  const solveBtn = document.getElementById('solveBtn');
  const sizeSelect = document.getElementById('sizeSelect');
  const stepsEl = document.getElementById('steps');
  const timeEl = document.getElementById('time');
  const padBtns = document.querySelectorAll('.pad-btn');

  let cols = parseInt(sizeSelect.value,10);
  let rows = cols;
  let maze = [];
  let player = {x:0,y:0};
  let goal = {x:cols-1,y:rows-1};
  let steps = 0;
  let startTime = 0;
  let running = false;
  let animTimer = null;
  let solvingPath = null;
  let cellPx = 16; // logical size per cell for drawing scale
  let moveDelay = 120; // ms between automatic moves (only used when auto-moving; here we step with keys)

  // responsive canvas fit (keep square)
  function fitCanvas(){
    const wrap = canvas.parentElement.clientWidth;
    canvas.width = wrap;
    canvas.height = wrap;
    draw();
  }
  window.addEventListener('resize', fitCanvas);

  function initMaze(){
    cols = parseInt(sizeSelect.value,10);
    rows = cols;
    maze = [];
    for(let y=0;y<rows;y++){
      const row = [];
      for(let x=0;x<cols;x++){
        row.push({x,y,visited:false,walls:[true,true,true,true]});
      }
      maze.push(row);
    }
    // DFS backtracker
    const stack = [];
    const start = maze[0][0];
    start.visited = true;
    stack.push(start);
    const dirs = [
      {dx:0,dy:-1,wall:0,opp:2},
      {dx:1,dy:0,wall:1,opp:3},
      {dx:0,dy:1,wall:2,opp:0},
      {dx:-1,dy:0,wall:3,opp:1},
    ];
    while(stack.length){
      const cur = stack[stack.length-1];
      const neighbors = [];
      for(const d of dirs){
        const nx = cur.x + d.dx, ny = cur.y + d.dy;
        if(nx>=0 && nx<cols && ny>=0 && ny<rows && !maze[ny][nx].visited){
          neighbors.push({d,nx,ny});
        }
      }
      if(neighbors.length){
        const pick = neighbors[Math.floor(Math.random()*neighbors.length)];
        const nxt = maze[pick.ny][pick.nx];
        cur.walls[pick.d.wall] = false;
        nxt.walls[pick.d.opp] = false;
        nxt.visited = true;
        stack.push(nxt);
      } else stack.pop();
    }
    // openings
    maze[0][0].walls[3] = false;
    maze[rows-1][cols-1].walls[1] = false;

    player = {x:0,y:0};
    goal = {x:cols-1,y:rows-1};
    steps = 0;
    startTime = performance.now();
    solvingPath = null;
    running = false;
    updateStats();
    fitCanvas();
    showStartOverlay(true);
    if(animTimer) cancelAnimationFrame(animTimer);
    animTimer = requestAnimationFrame(tickTimer);
  }

  function updateStats(){
    stepsEl.textContent = steps;
    timeEl.textContent = ((performance.now()-startTime)/1000).toFixed(1) + 's';
  }

  function tickTimer(){
    if(running){
      updateStats();
    }
    animTimer = requestAnimationFrame(tickTimer);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const cs = Math.floor(canvas.width / cols);
    // background
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--floor') || '#111827';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // walls
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall') || '#0b3d91';
    ctx.lineWidth = Math.max(1, cs/12);
    ctx.lineCap = 'square';
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const cell = maze[y][x];
        const px = x*cs, py = y*cs;
        ctx.beginPath();
        if(cell.walls[0]){ ctx.moveTo(px,py); ctx.lineTo(px+cs,py); }
        if(cell.walls[1]){ ctx.moveTo(px+cs,py); ctx.lineTo(px+cs,py+cs); }
        if(cell.walls[2]){ ctx.moveTo(px+cs,py+cs); ctx.lineTo(px,py+cs); }
        if(cell.walls[3]){ ctx.moveTo(px,py+cs); ctx.lineTo(px,py); }
        ctx.stroke();
      }
    }

    // solution path
    if(solvingPath){
      ctx.fillStyle = 'rgba(124,207,53,0.12)';
      for(const p of solvingPath){
        ctx.fillRect(p.x*cs+1, p.y*cs+1, cs-2, cs-2);
      }
    }

    // goal marker (small green square)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--goal') || '#7CCF35';
    ctx.fillRect(goal.x*cs + cs*0.18, goal.y*cs + cs*0.18, cs*0.64, cs*0.64);

    // player (circle)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player') || '#FFBF69';
    ctx.beginPath();
    ctx.arc(player.x*cs + cs/2, player.y*cs + cs/2, cs*0.28, 0, Math.PI*2);
    ctx.fill();
  }

  function canMoveFrom(x,y,dir){
    const cell = maze[y][x];
    if(dir==='up') return !cell.walls[0];
    if(dir==='right') return !cell.walls[1];
    if(dir==='down') return !cell.walls[2];
    if(dir==='left') return !cell.walls[3];
    return false;
  }

  function tryMove(dir){
    if(!canMoveFrom(player.x,player.y,dir)) return false;
    let nx = player.x, ny = player.y;
    if(dir==='up') ny--;
    if(dir==='down') ny++;
    if(dir==='left') nx--;
    if(dir==='right') nx++;
    if(nx<0||ny<0||nx>=cols||ny>=rows) return false;
    player.x = nx; player.y = ny;
    steps++;
    updateStats();
    draw();
    checkWin();
    return true;
  }

  function checkWin(){
    if(player.x===goal.x && player.y===goal.y){
      running = false;
      showGameOver();
      setTimeout(()=> alert(`Has guanyat! Temps: ${((performance.now()-startTime)/1000).toFixed(2)}s  Passos: ${steps}`), 120);
    }
  }

  function solveMaze(){
    const q = [];
    const visited = Array(rows).fill(0).map(()=>Array(cols).fill(false));
    const parent = Array(rows).fill(0).map(()=>Array(cols).fill(null));
    q.push({x:player.x,y:player.y});
    visited[player.y][player.x] = true;
    while(q.length){
      const cur = q.shift();
      if(cur.x===goal.x && cur.y===goal.y){
        const path = [];
        let p = cur;
        while(p){
          path.push({x:p.x,y:p.y});
          p = parent[p.y][p.x];
        }
        solvingPath = path.reverse();
        draw();
        return;
      }
      const dirs = [
        {dir:'up',dx:0,dy:-1},
        {dir:'right',dx:1,dy:0},
        {dir:'down',dx:0,dy:1},
        {dir:'left',dx:-1,dy:0},
      ];
      for(const d of dirs){
        const nx = cur.x + d.dx, ny = cur.y + d.dy;
        if(nx<0||ny<0||nx>=cols||ny>=rows) continue;
        if(!canMoveFrom(cur.x,cur.y,d.dir)) continue;
        if(!visited[ny][nx]){
          visited[ny][nx] = true;
          parent[ny][nx] = cur;
          q.push({x:nx,y:nx===undefined?0:ny});
        }
      }
    }
  }

  // keyboard controls (no auto-move): small debounce for fluid movement
  let lastMove = 0;
  window.addEventListener('keydown',(e)=>{
    if(!running) return;
    const now = performance.now();
    if(now - lastMove < 60) return;
    const k = e.key.toLowerCase();
    let moved = false;
    if(k==='arrowup' || k==='w') moved = tryMove('up');
    if(k==='arrowdown' || k==='s') moved = tryMove('down');
    if(k==='arrowleft' || k==='a') moved = tryMove('left');
    if(k==='arrowright' || k==='d') moved = tryMove('right');
    if(moved) lastMove = now;
  });

  // pad buttons
  padBtns.forEach(btn=>{
    btn.addEventListener('click', ()=> {
      if(!running) return;
      tryMove(btn.dataset.dir);
    });
  });

  // UI handlers
  function showStartOverlay(show){
    startButton.style.display = show ? 'block' : 'none';
    pauseContinue.style.display = show ? 'none' : (window.innerWidth<=560 ? 'block' : 'none');
    pauseReset.style.display = show ? 'none' : (window.innerWidth<=560 ? 'block' : 'none');
    gameOverReset.style.display = 'none';
  }
  function showGameOver(){
    startButton.style.display = 'none';
    pauseContinue.style.display = 'none';
    pauseReset.style.display = 'none';
    gameOverReset.style.display = 'block';
  }

  startButton.addEventListener('click', ()=>{
    running = true;
    startTime = performance.now();
    showStartOverlay(false);
    draw();
  });

  pauseContinue.addEventListener('click', ()=>{
    running = !running;
    pauseContinue.textContent = running ? '‚è∏' : '‚èØ';
  });
  pauseReset.addEventListener('click', ()=> initMaze());
  gameOverReset.addEventListener('click', ()=> initMaze());
  restartBtn.addEventListener('click', ()=> initMaze());
  solveBtn.addEventListener('click', ()=> { solvingPath = null; solveMaze(); });

  sizeSelect.addEventListener('change', ()=> initMaze());

  // initial boot
  initMaze();
  // ensure canvas fits
  setTimeout(fitCanvas,50);
})();
</script>
</body>
</html>
