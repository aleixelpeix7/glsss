<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Joc de la Serp</title>
  <style>
    :root{ --canvas-w:400px; --canvas-h:400px; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:#f0f0f0;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      padding:18px 8px;
    }
    h1 { margin:0; color:#333; font-size:20px; }
    #gameWrap{ position:relative; width:var(--canvas-w); }
    canvas {
      background:#222;
      display:block;
      border:2px solid #555;
      width:100%;
      height:auto;
    }
    #score { color:#444; font-size:14px; margin:6px 0 0 0; }
    .canvas-button {
      position:absolute;
      background:#fff;
      color:#111;
      border:1px solid #888;
      padding:8px 12px;
      font-size:14px;
      cursor:pointer;
      border-radius:6px;
      box-shadow:0 2px 6px rgba(0,0,0,0.25);
      user-select:none;
      z-index:10;
    }
    .hidden{ display:none; }
  </style>
</head>
<body>
  <h1>üêç Joc de la Serp</h1>
  <div id="gameWrap">
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <button id="startButton" class="canvas-button hidden" aria-label="Jugar">‚ñ∂Ô∏è Jugar</button>
    <button id="pauseContinue" class="canvas-button hidden" aria-label="Continuar">üîÑ Continuar</button>
    <button id="pauseReset" class="canvas-button hidden" aria-label="Reiniciar">üîÅ Reiniciar</button>
  </div>
  <p id="score">Puntuaci√≥: 0</p>

  <script>
/* Fitxer complet corregit: botons alineats i la serp no es mostra fins pr√©mer Jugar */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('gameWrap');
const scoreEl = document.getElementById('score');

const startButton = document.getElementById('startButton');
const pauseContinue = document.getElementById('pauseContinue');
const pauseReset = document.getElementById('pauseReset');

const gridSize = 20;
const INTERNAL_W = canvas.width; // 400
const INTERNAL_H = canvas.height; // 400
const tileCountX = INTERNAL_W / gridSize;
const tileCountY = INTERNAL_H / gridSize;

let snake = null; // sera array nom√©s quan el joc comenci
let direction = {x:0,y:0};
let nextDirection = {x:0,y:0};
let apple = {x:5,y:5};
let score = 0;
let gameInterval = null;
let paused = false;
let gameStarted = false;

const SPEEDS = { slow:300, normal:200, fast:100 };
let selectedSpeedKey = 'normal';
let snakeSpeed = SPEEDS[selectedSpeedKey];

const startMenuRect = { x:50, y:80, w:300, h:240 };
const pauseMenuRect = { x:50, y:100, w:300, h:200 };

/* ---- inicialitzacions que no mostren la serp ---- */
function initSnake(){
  snake = [ {x:10,y:10}, {x:9,y:10} ];
  direction = {x:0,y:0};
  nextDirection = {x:0,y:0};
  score = 0;
  scoreEl.textContent = 'Puntuaci√≥: 0';
}

/* Col¬∑loca poma evitant la serp (si existeix) */
function placeApple(){
  let tries = 0;
  do {
    apple.x = Math.floor(Math.random() * tileCountX);
    apple.y = Math.floor(Math.random() * tileCountY);
    tries++;
    if(tries>200) break;
  } while (snake && snake.some(s=>s.x===apple.x && s.y===apple.y));
}

/* ---- controls de joc ---- */
function startGame(){
  gameStarted = true;
  paused = false;
  hideButtons();
  initSnake();
  placeApple();
  direction = {x:1,y:0};
  nextDirection = {x:1,y:0};
  runInterval();
  draw();
}

function runInterval(){
  if(gameInterval) clearInterval(gameInterval);
  gameInterval = setInterval(gameLoop, snakeSpeed);
}

function pauseGame(){
  if(!gameStarted || paused) return;
  paused = true;
  if(gameInterval) clearInterval(gameInterval);
  showPauseMenu();
}

function resumeGame(){
  if(!gameStarted || !paused) return;
  paused = false;
  hideButtons();
  runInterval();
}

function resetToMenu(){
  if(gameInterval) clearInterval(gameInterval);
  gameStarted = false;
  paused = false;
  hideButtons();
  snake = null; // eliminar la serp visible
  direction = {x:0,y:0};
  nextDirection = {x:0,y:0};
  score = 0;
  scoreEl.textContent = 'Puntuaci√≥: 0';
  placeApple();
  draw();
  drawStartMenu();
  positionStartButton();
  showStartButton();
}

/* ---- bucle ---- */
function gameLoop(){
  // aplicar nextDirection evitant 180
  if(nextDirection.x !== direction.x || nextDirection.y !== direction.y){
    if(!(nextDirection.x === -direction.x && nextDirection.y === -direction.y)){
      direction = {...nextDirection};
    }
  }
  if(direction.x === 0 && direction.y === 0) return;

  const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

  if(head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY ||
     snake.some(p => p.x === head.x && p.y === head.y)){
    resetToMenu();
    return;
  }

  snake.unshift(head);
  if(head.x === apple.x && head.y === apple.y){
    score++;
    scoreEl.textContent = 'Puntuaci√≥: ' + score;
    placeApple();
  } else {
    snake.pop();
  }
  draw();
}

/* ---- dibuix ---- */
function draw(){
  // fons
  ctx.clearRect(0,0,INTERNAL_W,INTERNAL_H);
  ctx.fillStyle = '#222';
  ctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);

  // dibuixar serp nom√©s si existeix (no abans de pr√©mer Jugar)
  if(snake){
    for(let i=0;i<snake.length;i++){
      const p = snake[i];
      ctx.fillStyle = '#0f0';
      ctx.fillRect(p.x * gridSize, p.y * gridSize, gridSize-2, gridSize-2);
    }

    // ulls orientats segons direction (cap)
    if(snake.length>0){
      const head = snake[0];
      const cellX = head.x * gridSize;
      const cellY = head.y * gridSize;
      const eyeSize = 4;
      let e1 = {x: cellX + 2, y: cellY + 4};
      let e2 = {x: cellX + 2, y: cellY + 12};
      if(direction.x === 1){
        e1 = {x: cellX + (gridSize - 6), y: cellY + 4};
        e2 = {x: cellX + (gridSize - 6), y: cellY + 12};
      } else if(direction.x === -1){
        e1 = {x: cellX + 2, y: cellY + 4};
        e2 = {x: cellX + 2, y: cellY + 12};
      } else if(direction.y === -1){
        e1 = {x: cellX + 6, y: cellY + 2};
        e2 = {x: cellX + 14, y: cellY + 2};
      } else if(direction.y === 1){
        e1 = {x: cellX + 6, y: cellY + (gridSize - 6)};
        e2 = {x: cellX + 14, y: cellY + (gridSize - 6)};
      } else {
        e1 = {x: cellX + 2, y: cellY + 4};
        e2 = {x: cellX + 2, y: cellY + 12};
      }
      ctx.fillStyle = '#00f';
      ctx.fillRect(e1.x, e1.y, eyeSize, eyeSize);
      ctx.fillRect(e2.x, e2.y, eyeSize, eyeSize);
    }
  }

  // poma
  ctx.fillStyle = '#f00';
  ctx.fillRect(apple.x * gridSize, apple.y * gridSize, gridSize-2, gridSize-2);

  if(!gameStarted) drawStartMenu();
  if(paused) drawPauseMenu();
}

/* ---- menus dins canvas ---- */
function drawStartMenu(){
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(startMenuRect.x, startMenuRect.y, startMenuRect.w, startMenuRect.h);

  ctx.fillStyle = '#fff';
  ctx.font = '18px system-ui, sans-serif';
  ctx.fillText('Benvingut al joc de la serp!', startMenuRect.x + 24, startMenuRect.y + 36);

  ctx.font = '14px system-ui, sans-serif';
  ctx.fillText('Selecciona la velocitat:', startMenuRect.x + 24, startMenuRect.y + 72);

  const baseY = startMenuRect.y + 110;
  const cx = startMenuRect.x + 50;
  const gap = 80;
  drawSpeedBox(cx, baseY, 'üê¢', 'slow');
  drawSpeedBox(cx + gap, baseY, '‚öñÔ∏è', 'normal');
  drawSpeedBox(cx + gap*2, baseY, 'üöÄ', 'fast');

  ctx.fillStyle = '#ccc';
  ctx.font = '12px system-ui, sans-serif';
  ctx.fillText('Fes clic sobre una icona per canviar la velocitat.', startMenuRect.x + 28, startMenuRect.y + startMenuRect.h - 32);

  positionStartButton();
  showStartButton();
}

function drawSpeedBox(x, y, icon, key){
  const w = 54, h = 48;
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(x, y, w, h);
  if(selectedSpeedKey === key){
    ctx.strokeStyle = '#7af';
    ctx.lineWidth = 2;
    ctx.strokeRect(x+1, y+1, w-2, h-2);
  } else {
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x+1, y+1, w-2, h-2);
  }
  ctx.font = '22px system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fff';
  ctx.fillText(icon, x + w/2, y + h/2 - 2);
  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
}

function drawPauseMenu(){
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(pauseMenuRect.x, pauseMenuRect.y, pauseMenuRect.w, pauseMenuRect.h);

  ctx.fillStyle = '#fff';
  ctx.font = '20px system-ui, sans-serif';
  ctx.fillText('‚è∏ Joc en pausa', pauseMenuRect.x + 80, pauseMenuRect.y + 42);

  ctx.font = '18px system-ui, sans-serif';
  ctx.fillText('Puntuaci√≥', pauseMenuRect.x + 120, pauseMenuRect.y + 88);
  ctx.font = '34px system-ui, sans-serif';
  ctx.fillStyle = '#7af';
  ctx.fillText(String(score), pauseMenuRect.x + 160, pauseMenuRect.y + 130);

  positionPauseButtons();
  showPauseButtons();
}

/* ---- botons HTML sobre el canvas (posici√≥ amb escala) ---- */
function getCanvasRectScaled(){
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / INTERNAL_W;
  const scaleY = rect.height / INTERNAL_H;
  return { rect, scaleX, scaleY };
}

function positionStartButton(){
  const { rect, scaleX } = getCanvasRectScaled();
  // calcular posici√≥ CSS a partir de coordenades internes del men√∫
  const internalX = startMenuRect.x + startMenuRect.w/2 - 40; // -40 per centrar bot√≥ (amplada aprox)
  const internalY = startMenuRect.y + startMenuRect.h - 48;
  const left = rect.left + internalX * scaleX;
  const top = rect.top + internalY * (rect.height / INTERNAL_H);
  startButton.style.left = Math.round(left) + 'px';
  startButton.style.top  = Math.round(top)  + 'px';
}

function positionPauseButtons(){
  const { rect, scaleX } = getCanvasRectScaled();
  const internalLeftC = pauseMenuRect.x + 40;
  const internalLeftR = pauseMenuRect.x + pauseMenuRect.w - 120;
  const internalTop = pauseMenuRect.y + pauseMenuRect.h - 56;
  pauseContinue.style.left = Math.round(rect.left + internalLeftC * scaleX) + 'px';
  pauseContinue.style.top  = Math.round(rect.top + internalTop * (rect.height / INTERNAL_H)) + 'px';
  pauseReset.style.left    = Math.round(rect.left + internalLeftR * scaleX) + 'px';
  pauseReset.style.top     = Math.round(rect.top + internalTop * (rect.height / INTERNAL_H)) + 'px';
}

function showStartButton(){ startButton.classList.remove('hidden'); }
function hideStartButton(){ startButton.classList.add('hidden'); }
function showPauseButtons(){ pauseContinue.classList.remove('hidden'); pauseReset.classList.remove('hidden'); }
function hidePauseButtons(){ pauseContinue.classList.add('hidden'); pauseReset.classList.add('hidden'); }
function showPauseMenu(){ draw(); drawPauseMenu(); }
function hideButtons(){ startButton.classList.add('hidden'); pauseContinue.classList.add('hidden'); pauseReset.classList.add('hidden'); }

/* ---- interacci√≥ amb el canvas ---- */
canvas.addEventListener('click', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  // convertir a coordenades internes (tenint en compte escala)
  const scaleX = rect.width / INTERNAL_W;
  const scaleY = rect.height / INTERNAL_H;
  const x = Math.floor((ev.clientX - rect.left) / scaleX);
  const y = Math.floor((ev.clientY - rect.top) / scaleY);

  if(!gameStarted){
    if(pointInside(x,y, startMenuRect)){
      const baseY = startMenuRect.y + 110;
      const cx = startMenuRect.x + 50;
      const gap = 80;
      const boxes = [
        {key:'slow', x:cx, y:baseY, w:54, h:48},
        {key:'normal', x:cx+gap, y:baseY, w:54, h:48},
        {key:'fast', x:cx+gap*2, y:baseY, w:54, h:48}
      ];
      for(const b of boxes){
        if(pointInside(x,y, {x:b.x,y:b.y,w:b.w,h:b.h})){
          selectedSpeedKey = b.key;
          snakeSpeed = SPEEDS[selectedSpeedKey];
          draw();
          return;
        }
      }
    }
    return;
  }

  if(paused){
    if(pointInside(x,y, pauseMenuRect)){
      // botons reals estan disponibles; no fem res amb el clic dins canvas
      return;
    }
  }
});

function pointInside(px,py, rect){
  return px >= rect.x && px <= rect.x + rect.w && py >= rect.y && py <= rect.y + rect.h;
}

/* ---- botons HTML ---- */
startButton.addEventListener('click', ()=>{
  snakeSpeed = SPEEDS[selectedSpeedKey];
  startGame();
});

pauseContinue.addEventListener('click', ()=> resumeGame());
pauseReset.addEventListener('click', ()=> { resetToMenu(); });

/* ---- teclat ---- */
document.addEventListener('keydown', (e)=>{
  if(!gameStarted){
    if(e.key === 'Enter'){
      snakeSpeed = SPEEDS[selectedSpeedKey];
      startGame();
    }
    return;
  }

  if(e.key === 'Escape'){
    pauseGame();
    return;
  }

  if(paused){
    if(e.key === 'c' || e.key === 'C') { resumeGame(); return; }
    if(e.key === 'r' || e.key === 'R') { resetToMenu(); return; }
    return;
  }

  if(e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W'){
    if(direction.y !== 1) nextDirection = {x:0,y:-1};
  } else if(e.key === 'ArrowDown' || e.key === 's' || e.key === 'S'){
    if(direction.y !== -1) nextDirection = {x:0,y:1};
  } else if(e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){
    if(direction.x !== 1) nextDirection = {x:-1,y:0};
  } else if(e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){
    if(direction.x !== -1) nextDirection = {x:1,y:0};
  }
});

/* ---- utilitats i arrencada ---- */
window.addEventListener('resize', updateButtonPositions);
window.addEventListener('scroll', updateButtonPositions);

function updateButtonPositions(){
  if(!gameStarted) positionStartButton();
  if(paused) positionPauseButtons();
}

initDisplay();
let posInterval = setInterval(()=> {
  if(!gameStarted) positionStartButton();
  if(paused) positionPauseButtons();
}, 120);

function initDisplay(){
  snake = null; // no mostrar la serp fins pr√©mer Jugar
  placeApple();
  draw();
  drawStartMenu();
  positionStartButton();
  showStartButton();
}

/* neteja */
window.addEventListener('beforeunload', ()=> {
  if(posInterval) clearInterval(posInterval);
  if(gameInterval) clearInterval(gameInterval);
});
  </script>
</body>
</html>

